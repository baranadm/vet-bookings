[1mdiff --git a/src/main/java/pl/baranowski/dev/controller/DoctorController.java b/src/main/java/pl/baranowski/dev/controller/DoctorController.java[m
[1mindex 7f59db3..3504e81 100644[m
[1m--- a/src/main/java/pl/baranowski/dev/controller/DoctorController.java[m
[1m+++ b/src/main/java/pl/baranowski/dev/controller/DoctorController.java[m
[36m@@ -40,7 +40,7 @@[m [mpublic class DoctorController {[m
 	@GetMapping(value="/{id}", produces="application/json;charset=UTF-8")[m
 	@ResponseStatus(HttpStatus.OK)[m
 	public @ResponseBody DoctorDTO getById(@PathVariable String id) throws NumberFormatException {[m
[31m-		return doctorService.getById(Long.decode(id));[m
[32m+[m		[32mreturn doctorService.getDto(Long.decode(id));[m
 	}[m
 	[m
 	@GetMapping(value="/", produces="application/json;charset=UTF-8")[m
[1mdiff --git a/src/main/java/pl/baranowski/dev/controller/PatientController.java b/src/main/java/pl/baranowski/dev/controller/PatientController.java[m
[1mindex 7691c4c..06dfdaa 100644[m
[1m--- a/src/main/java/pl/baranowski/dev/controller/PatientController.java[m
[1m+++ b/src/main/java/pl/baranowski/dev/controller/PatientController.java[m
[36m@@ -32,7 +32,7 @@[m [mpublic class PatientController {[m
 	[m
 	@GetMapping(value="/{id}", produces="application/json;charset=UTF-8")[m
 	public @ResponseBody PatientDTO getById(@PathVariable String id) {[m
[31m-		return patientService.getById(Long.decode(id));[m
[32m+[m		[32mreturn patientService.getDto(Long.decode(id));[m
 	}[m
 	[m
 	@GetMapping(value="/", produces = "application/json;charset=UTF-8")[m
[1mdiff --git a/src/main/java/pl/baranowski/dev/controller/VisitController.java b/src/main/java/pl/baranowski/dev/controller/VisitController.java[m
[1mindex 06b2956..a096a17 100644[m
[1m--- a/src/main/java/pl/baranowski/dev/controller/VisitController.java[m
[1m+++ b/src/main/java/pl/baranowski/dev/controller/VisitController.java[m
[36m@@ -25,11 +25,12 @@[m [mimport org.springframework.web.bind.annotation.ResponseStatus;[m
 import org.springframework.web.bind.annotation.RestController;[m
 [m
 import pl.baranowski.dev.dto.NewVisitDTO;[m
[31m-import pl.baranowski.dev.dto.SingleCheckResultDTO;[m
 import pl.baranowski.dev.dto.VisitDTO;[m
 import pl.baranowski.dev.exception.NewVisitNotPossibleException;[m
 import pl.baranowski.dev.exception.SearchRequestInvalidException;[m
[32m+[m[32mimport pl.baranowski.dev.model.AvailableSlotsAtTheDoctor;[m
 import pl.baranowski.dev.exception.DoctorNotActiveException;[m
[32m+[m[32mimport pl.baranowski.dev.exception.InvalidEpochTimeException;[m
 import pl.baranowski.dev.service.DoctorService;[m
 import pl.baranowski.dev.service.VisitService;[m
 [m
[36m@@ -61,13 +62,12 @@[m [mpublic class VisitController {[m
 	 * }][m
 	 */[m
 	@GetMapping(value="/check", produces = "application/json;charset=UTF-8")[m
[31m-	public @ResponseBody List<SingleCheckResultDTO> findFreeSlots([m
[32m+[m	[32mpublic @ResponseBody List<AvailableSlotsAtTheDoctor> findFreeSlots([m
 			@RequestParam("animalTypeName") @NotBlank(message="Invalid search criteria: animalTypeName should not be empty.") String animalTypeName,[m
 			@RequestParam("medSpecialtyName") @NotBlank(message="Invalid search criteria: medSpecialtyName should not be empty.") String medSpecialtyName,[m
 			@RequestParam("epochStart") @NotBlank(message="Invalid search criteria: epochStart should not be empty.") @Pattern(regexp = "[0-9]+", message = "Invalid epoch format - only digits allowed") String epochStart,[m
[31m-			@RequestParam("epochEnd") @NotBlank(message="Invalid search criteria: epochEnd should not be empty.") @Pattern(regexp = "[0-9]+", message = "Invalid epoch format - only digits allowed") String epochEnd,[m
[31m-			@RequestParam("interval") @NotBlank(message="Invalid search criteria: interval should not be empty.")	@Pattern(regexp = "[0-9]+", message = "Invalid interval format - only digits allowed") String interval) throws SearchRequestInvalidException {[m
[31m-		return visitService.findFreeSlots(animalTypeName, medSpecialtyName, epochStart, epochEnd, interval);[m
[32m+[m			[32m@RequestParam("epochEnd") @NotBlank(message="Invalid search criteria: epochEnd should not be empty.") @Pattern(regexp = "[0-9]+", message = "Invalid epoch format - only digits allowed") String epochEnd) throws InvalidEpochTimeException {[m
[32m+[m		[32mreturn visitService.findAvailableSlots(animalTypeName, medSpecialtyName, epochStart, epochEnd);[m
 	}[m
 	[m
 	@GetMapping(value="/{id}", produces="application/json;charset=UTF-8")[m
[1mdiff --git a/src/main/java/pl/baranowski/dev/entity/Doctor.java b/src/main/java/pl/baranowski/dev/entity/Doctor.java[m
[1mindex 46fad50..40b4771 100644[m
[1m--- a/src/main/java/pl/baranowski/dev/entity/Doctor.java[m
[1m+++ b/src/main/java/pl/baranowski/dev/entity/Doctor.java[m
[36m@@ -201,26 +201,39 @@[m [mpublic class Doctor {[m
 		return worksTillHour;[m
 	}[m
 	[m
[31m-	/**[m
[31m-	 *  Checks, if Doctor is busy at epoch start with given duration[m
[31m-	 * @param start - epoch, seconds, inclusive[m
[31m-	 * @param dur - seconds[m
[31m-	 * @return true, if busy[m
[31m-	 */[m
[31m-	public boolean isBusyAt(long start, long dur) {[m
[31m-		// checks, if time is inside working hours[m
[31m-		Instant instantStart = Instant.ofEpochSecond(start);[m
[31m-		ZonedDateTime zonedStart = ZonedDateTime.ofInstant(instantStart, ZoneId.systemDefault());[m
[31m-		if(zonedStart.getHour() < worksFromHour) {[m
[31m-			return true; // start before working time = busy[m
[31m-		} else if (zonedStart.getHour() + dur/60/60 > worksTillHour){[m
[31m-			return true; // end after working time = busy[m
[31m-		}[m
[31m-		// checks, if there is another visit at epoch[m
[31m-		boolean isBusy = visits.stream().anyMatch(visit -> [m
[31m-								(start >= visit.getEpoch() && start < visit.getEpoch() + visit.getDuration()) [m
[31m-								|| (start + dur <= visit.getEpoch() + visit.getDuration() && start + dur > visit.getEpoch()));[m
[31m-		return isBusy;[m
[32m+[m	[32mpublic boolean isAvailableAt(long epochInSeconds) {[m
[32m+[m		[32mreturn worksAt(epochInSeconds) && !hasVisitsAtEpoch(epochInSeconds);[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mpublic boolean worksAt(long epochInSeconds) {[m
[32m+[m		[32mZonedDateTime zonedStart = toZonedDateTime(epochInSeconds);[m
[32m+[m		[32mreturn worksAtTime(zonedStart) && worksAtDate(zonedStart);[m
[32m+[m[41m		[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mprivate boolean worksAtTime(ZonedDateTime zonedStart) {[m
[32m+[m		[32mboolean afterStartOfWorkingHours = zonedStart.getHour() >= worksFromHour;[m
[32m+[m		[32mboolean beforeEndOfWorkingHours = zonedStart.getHour() <= worksTillHour;[m
[32m+[m		[32mreturn afterStartOfWorkingHours && beforeEndOfWorkingHours;[m
[32m+[m	[32m}[m
[32m+[m[41m	[m
[32m+[m	[32mprivate boolean worksAtDate(ZonedDateTime zonedStart) {[m
[32m+[m		[32mreturn workingDays.contains(zonedStart.getDayOfWeek());[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mprivate ZonedDateTime toZonedDateTime(long epochInSeconds) {[m
[32m+[m		[32mInstant instant = Instant.ofEpochSecond(epochInSeconds);[m
[32m+[m		[32mZonedDateTime zoned = ZonedDateTime.ofInstant(instant, ZoneId.systemDefault());[m
[32m+[m		[32mreturn zoned;[m
[32m+[m	[32m}[m
[32m+[m[41m	[m
[32m+[m	[32mpublic boolean hasVisitsAtEpoch(long epochInSeconds) {[m
[32m+[m		[32mreturn visits.stream().anyMatch(visit ->[m[41m [m
[32m+[m								[32m{[m
[32m+[m									[32mboolean isEpochAfterVisitStart = epochInSeconds >= visit.getEpoch();[m
[32m+[m									[32mboolean isEpochAfterVisitEnd = epochInSeconds < visit.getEpoch() + visit.getDuration();[m
[32m+[m									[32mreturn isEpochAfterVisitStart && isEpochAfterVisitEnd;[m
[32m+[m								[32m});[m
 	}[m
 [m
 	@Override[m
[1mdiff --git a/src/main/java/pl/baranowski/dev/entity/Patient.java b/src/main/java/pl/baranowski/dev/entity/Patient.java[m
[1mindex db1f62d..597fd4a 100644[m
[1m--- a/src/main/java/pl/baranowski/dev/entity/Patient.java[m
[1m+++ b/src/main/java/pl/baranowski/dev/entity/Patient.java[m
[36m@@ -104,6 +104,10 @@[m [mpublic class Patient {[m
 	public void setOwnerEmail(String ownerEmail) {[m
 		this.ownerEmail = ownerEmail;[m
 	}[m
[32m+[m[41m	[m
[32m+[m	[32mpublic boolean hasVisitsAt(long epochInSeconds) {[m
[32m+[m		[32mreturn visits.stream().filter(visit -> visit.getEpoch() == epochInSeconds).count() > 0;[m
[32m+[m	[32m}[m
 [m
 	@Override[m
 	public int hashCode() {[m
[1mdiff --git a/src/main/java/pl/baranowski/dev/entity/Visit.java b/src/main/java/pl/baranowski/dev/entity/Visit.java[m
[1mindex d05c06c..0f068c3 100644[m
[1m--- a/src/main/java/pl/baranowski/dev/entity/Visit.java[m
[1m+++ b/src/main/java/pl/baranowski/dev/entity/Visit.java[m
[36m@@ -7,6 +7,9 @@[m [mimport javax.persistence.Id;[m
 import javax.persistence.JoinColumn;[m
 import javax.persistence.ManyToOne;[m
 [m
[32m+[m[32mimport pl.baranowski.dev.exception.DoctorNotActiveException;[m
[32m+[m[32mimport pl.baranowski.dev.exception.NewVisitNotPossibleException;[m
[32m+[m
 @Entity[m
 public class Visit {[m
 [m
[36m@@ -22,21 +25,95 @@[m [mpublic class Visit {[m
 	@JoinColumn(name = "patient_id")[m
 	private Patient patient; // required[m
 	[m
[31m-	private long epoch; // required[m
[32m+[m	[32mprivate long epochInSeconds; // required[m
 	private long duration = 3600; // optional, default = 3600[m
 	private Boolean isConfirmed = false; // optional, default = false[m
 	[m
 	public Visit() {[m
 	}[m
 	[m
[31m-	private Visit(VisitBuilder visitBuilder) {[m
[32m+[m	[32mprivate Visit(VisitBuilder visitBuilder) throws NewVisitNotPossibleException, DoctorNotActiveException {[m
 		this.doctor = visitBuilder.doctor;[m
 		this.patient = visitBuilder.patient;[m
[31m-		this.epoch = visitBuilder.epoch;[m
[32m+[m		[32mthis.epochInSeconds = visitBuilder.epoch;[m
 		this.duration = visitBuilder.duration;[m
 		this.isConfirmed = visitBuilder.isConfirmed;[m
[32m+[m		[32mvalidateVisit();[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mprivate void validateVisit() throws NewVisitNotPossibleException, DoctorNotActiveException {[m
[32m+[m		[32mvalidateEpoch();[m
[32m+[m		[32mvalidateDoctor();[m
[32m+[m		[32mvalidatePatient();[m
[32m+[m		[32mvalidateAnimalTypeMatching();[m
[32m+[m[41m		[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mprivate void validateEpoch() throws NewVisitNotPossibleException {[m
[32m+[m		[32mthrowIfEpochIsNotInFuture();[m
[32m+[m		[32mthrowIfEpochIsNotAtTheTopOfTheHour();[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mprivate void throwIfEpochIsNotInFuture() throws NewVisitNotPossibleException {[m
[32m+[m		[32mif(epochInSeconds - System.currentTimeMillis()/1000 < 0) {[m
[32m+[m			[32mthrow new NewVisitNotPossibleException("Creating new Visit failed: provided epoch time is not in the future.");[m
[32m+[m		[32m}[m
 	}[m
 [m
[32m+[m	[32mprivate void throwIfEpochIsNotAtTheTopOfTheHour() throws NewVisitNotPossibleException {[m
[32m+[m		[32mif(epochInSeconds % 3600 != 0) {[m
[32m+[m			[32mthrow new NewVisitNotPossibleException("Time should be at exact hour (at the top of the hour).");[m
[32m+[m		[32m}[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mprivate void validateDoctor() throws DoctorNotActiveException, NewVisitNotPossibleException {[m
[32m+[m		[32mthrowIfDoctorIsInactive();[m
[32m+[m		[32mthrowIfDoctorIsBusyAtEpoch();[m
[32m+[m		[32mthrowIfDoctorDoesNotWorkAtEpoch();[m
[32m+[m	[32m}[m
[32m+[m[41m	[m
[32m+[m	[32mprivate void throwIfDoctorIsInactive() throws DoctorNotActiveException {[m
[32m+[m		[32mif(!doctor.isActive()) {[m
[32m+[m			[32mthrow new DoctorNotActiveException("Creating Visit failed. Doctor with id " + doctor.getId() + " is not active.");[m
[32m+[m		[32m}[m
[32m+[m	[32m}[m
[32m+[m[41m	[m
[32m+[m	[32mprivate void throwIfDoctorIsBusyAtEpoch() throws NewVisitNotPossibleException {[m
[32m+[m		[32mif(doctor.hasVisitsAtEpoch(epochInSeconds)) {[m
[32m+[m			[32mthrow new NewVisitNotPossibleException("Doctor with id " + doctor.getId() + " is busy at provided time.");[m
[32m+[m		[32m}[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mprivate void throwIfDoctorDoesNotWorkAtEpoch() throws NewVisitNotPossibleException {[m
[32m+[m		[32mif(!doctor.worksAt(epochInSeconds)) {[m
[32m+[m			[32mthrow new NewVisitNotPossibleException("Doctor with id " + doctor.getId() + " does not work at given time.");[m
[32m+[m		[32m}[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mprivate void validatePatient() throws NewVisitNotPossibleException {[m
[32m+[m		[32mthrowIfPatientBusyAtEpoch();[m
[32m+[m	[32m}[m
[32m+[m[41m	[m
[32m+[m	[32m/*[m
[32m+[m	[32m * Checks, if Patient has any visits at epoch.[m
[32m+[m	[32m * Unconfirmed visits are also considered.[m
[32m+[m	[32m */[m
[32m+[m	[32mprivate void throwIfPatientBusyAtEpoch() throws NewVisitNotPossibleException {[m
[32m+[m		[32mif(patient.hasVisitsAt(epochInSeconds)) {[m
[32m+[m			[32mthrow new NewVisitNotPossibleException("Patient has another visit at this time.");[m
[32m+[m		[32m}[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mprivate void validateAnimalTypeMatching() throws NewVisitNotPossibleException {[m
[32m+[m		[32mif(!animalTypeMatches()) {[m
[32m+[m			[32mthrow new NewVisitNotPossibleException("Patient's animal type does not match Doctor's animal types");[m
[32m+[m		[32m}[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mprivate boolean animalTypeMatches() {[m
[32m+[m		[32mreturn doctor.getAnimalTypes().contains(patient.getAnimalType());[m
[32m+[m	[32m}[m
[32m+[m[41m	[m
 	public Long getId() {[m
 		return id;[m
 	}[m
[36m@@ -50,7 +127,7 @@[m [mpublic class Visit {[m
 	}[m
 [m
 	public long getEpoch() {[m
[31m-		return epoch;[m
[32m+[m		[32mreturn epochInSeconds;[m
 	}[m
 	[m
 	public long getDuration() {[m
[36m@@ -89,7 +166,7 @@[m [mpublic class Visit {[m
 			return this;[m
 		}[m
 		[m
[31m-		public Visit build() {[m
[32m+[m		[32mpublic Visit build() throws NewVisitNotPossibleException, DoctorNotActiveException {[m
 			return new Visit(this);[m
 		}[m
 	}[m
[36m@@ -99,7 +176,7 @@[m [mpublic class Visit {[m
 		final int prime = 31;[m
 		int result = 1;[m
 		result = prime * result + (int) (duration ^ (duration >>> 32));[m
[31m-		result = prime * result + (int) (epoch ^ (epoch >>> 32));[m
[32m+[m		[32mresult = prime * result + (int) (epochInSeconds ^ (epochInSeconds >>> 32));[m
 		result = prime * result + ((id == null) ? 0 : id.hashCode());[m
 		result = prime * result + ((isConfirmed == null) ? 0 : isConfirmed.hashCode());[m
 		result = prime * result + ((patient == null) ? 0 : patient.hashCode());[m
[36m@@ -118,7 +195,7 @@[m [mpublic class Visit {[m
 		Visit other = (Visit) obj;[m
 		if (duration != other.duration)[m
 			return false;[m
[31m-		if (epoch != other.epoch)[m
[32m+[m		[32mif (epochInSeconds != other.epochInSeconds)[m
 			return false;[m
 		if (id == null) {[m
 			if (other.id != null)[m
[36m@@ -145,7 +222,7 @@[m [mpublic class Visit {[m
 [m
 	@Override[m
 	public String toString() {[m
[31m-		return "Visit [id=" + id + ", doctor=" + doctor + ", patient=" + patient + ", epoch=" + epoch + ", duration="[m
[32m+[m		[32mreturn "Visit [id=" + id + ", doctor=" + doctor + ", patient=" + patient + ", epoch=" + epochInSeconds + ", duration="[m
 				+ duration + ", isConfirmed=" + isConfirmed + "]";[m
 	}[m
 	[m
[1mdiff --git a/src/main/java/pl/baranowski/dev/mapper/CustomMapper.java b/src/main/java/pl/baranowski/dev/mapper/CustomMapper.java[m
[1mindex 47aff31..ea7abc9 100644[m
[1m--- a/src/main/java/pl/baranowski/dev/mapper/CustomMapper.java[m
[1m+++ b/src/main/java/pl/baranowski/dev/mapper/CustomMapper.java[m
[36m@@ -5,6 +5,7 @@[m [mimport java.math.BigDecimal;[m
 import org.springframework.stereotype.Component;[m
 [m
 import pl.baranowski.dev.dto.AnimalTypeDTO;[m
[32m+[m[32mimport pl.baranowski.dev.dto.AvailableSlotsAtTheDoctorDTO;[m
 import pl.baranowski.dev.dto.MedSpecialtyDTO;[m
 import pl.baranowski.dev.dto.PatientDTO;[m
 import pl.baranowski.dev.dto.DoctorDTO;[m
[36m@@ -14,6 +15,7 @@[m [mimport pl.baranowski.dev.entity.MedSpecialty;[m
 import pl.baranowski.dev.entity.Patient;[m
 import pl.baranowski.dev.entity.Doctor;[m
 import pl.baranowski.dev.entity.Visit;[m
[32m+[m[32mimport pl.baranowski.dev.model.AvailableSlotsAtTheDoctor;[m
 [m
 @Component[m
 public class CustomMapper {[m
[36m@@ -72,4 +74,10 @@[m [mpublic class CustomMapper {[m
 		VisitDTO dto = new VisitDTO(visit.getId(), toDto(visit.getDoctor()), toDto(visit.getPatient()), visit.getEpoch(), visit.getIsConfirmed());[m
 		return dto;[m
 	}[m
[31m-}[m
[32m+[m
[32m+[m	[32mpublic AvailableSlotsAtTheDoctorDTO toDto(AvailableSlotsAtTheDoctor availableSlots) {[m
[32m+[m		[32mDoctorDTO doctorDTO = toDto(availableSlots.getDoctor());[m
[32m+[m		[32mAvailableSlotsAtTheDoctorDTO dto = new AvailableSlotsAtTheDoctorDTO(doctorDTO, availableSlots.getEpochFreeTimes());[m
[32m+[m		[32mreturn dto;[m
[32m+[m	[32m}[m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/src/main/java/pl/baranowski/dev/model/AvailableSlotsAtTheDoctor.java b/src/main/java/pl/baranowski/dev/model/AvailableSlotsAtTheDoctor.java[m
[1mindex a03655d..b25ecf1 100644[m
[1m--- a/src/main/java/pl/baranowski/dev/model/AvailableSlotsAtTheDoctor.java[m
[1m+++ b/src/main/java/pl/baranowski/dev/model/AvailableSlotsAtTheDoctor.java[m
[36m@@ -1,39 +1,32 @@[m
[31m-package pl.baranowski.dev.dto;[m
[32m+[m[32mpackage pl.baranowski.dev.model;[m
 [m
 import java.util.List;[m
 [m
[31m-public class SingleCheckResultDTO {[m
[31m-	private DoctorDTO doctorDTO;[m
[31m-	private List<Long> epochFreeTimes;[m
[31m-	[m
[31m-	public SingleCheckResultDTO(DoctorDTO doctorDTO, List<Long> epochFreeTimes) {[m
[31m-		super();[m
[31m-		this.doctorDTO = doctorDTO;[m
[31m-		this.epochFreeTimes = epochFreeTimes;[m
[31m-	}[m
[32m+[m[32mimport pl.baranowski.dev.entity.Doctor;[m
 [m
[31m-	public DoctorDTO getDoctorDTO() {[m
[31m-		return doctorDTO;[m
[32m+[m[32mpublic class AvailableSlotsAtTheDoctor {[m
[32m+[m	[32mprivate final Doctor doctor;[m
[32m+[m	[32mprivate final List<Long> availableEpochTimes;[m
[32m+[m[41m	[m
[32m+[m	[32mpublic AvailableSlotsAtTheDoctor(Doctor doctor, List<Long> epochFreeTimes) {[m
[32m+[m		[32mthis.doctor = doctor;[m
[32m+[m		[32mthis.availableEpochTimes = epochFreeTimes;[m
 	}[m
 [m
[31m-	public void setDoctorDTO(DoctorDTO doctorDTO) {[m
[31m-		this.doctorDTO = doctorDTO;[m
[32m+[m	[32mpublic Doctor getDoctor() {[m
[32m+[m		[32mreturn doctor;[m
 	}[m
 [m
 	public List<Long> getEpochFreeTimes() {[m
[31m-		return epochFreeTimes;[m
[31m-	}[m
[31m-[m
[31m-	public void setEpochFreeTimes(List<Long> epochFreeTimes) {[m
[31m-		this.epochFreeTimes = epochFreeTimes;[m
[32m+[m		[32mreturn availableEpochTimes;[m
 	}[m
 	[m
 	@Override[m
 	public int hashCode() {[m
 		final int prime = 31;[m
 		int result = 1;[m
[31m-		result = prime * result + ((epochFreeTimes == null) ? 0 : epochFreeTimes.hashCode());[m
[31m-		result = prime * result + ((doctorDTO == null) ? 0 : doctorDTO.hashCode());[m
[32m+[m		[32mresult = prime * result + ((availableEpochTimes == null) ? 0 : availableEpochTimes.hashCode());[m
[32m+[m		[32mresult = prime * result + ((doctor == null) ? 0 : doctor.hashCode());[m
 		return result;[m
 	}[m
 [m
[36m@@ -45,23 +38,23 @@[m [mpublic class SingleCheckResultDTO {[m
 			return false;[m
 		if (getClass() != obj.getClass())[m
 			return false;[m
[31m-		SingleCheckResultDTO other = (SingleCheckResultDTO) obj;[m
[31m-		if (epochFreeTimes == null) {[m
[31m-			if (other.epochFreeTimes != null)[m
[32m+[m		[32mAvailableSlotsAtTheDoctor other = (AvailableSlotsAtTheDoctor) obj;[m
[32m+[m		[32mif (availableEpochTimes == null) {[m
[32m+[m			[32mif (other.availableEpochTimes != null)[m
 				return false;[m
[31m-		} else if (!epochFreeTimes.equals(other.epochFreeTimes))[m
[32m+[m		[32m} else if (!availableEpochTimes.equals(other.availableEpochTimes))[m
 			return false;[m
[31m-		if (doctorDTO == null) {[m
[31m-			if (other.doctorDTO != null)[m
[32m+[m		[32mif (doctor == null) {[m
[32m+[m			[32mif (other.doctor != null)[m
 				return false;[m
[31m-		} else if (!doctorDTO.equals(other.doctorDTO))[m
[32m+[m		[32m} else if (!doctor.equals(other.doctor))[m
 			return false;[m
 		return true;[m
 	}[m
 [m
 	@Override[m
 	public String toString() {[m
[31m-		return "CheckResultDTO [doctorDTO=" + doctorDTO + ", epochFreeTimes=" + epochFreeTimes + "]";[m
[32m+[m		[32mreturn "CheckResult [doctor=" + doctor + ", epochFreeTimes=" + availableEpochTimes + "]";[m
 	}[m
 	[m
 }[m
[1mdiff --git a/src/main/java/pl/baranowski/dev/service/DoctorService.java b/src/main/java/pl/baranowski/dev/service/DoctorService.java[m
[1mindex 9d897b7..c26923a 100644[m
[1m--- a/src/main/java/pl/baranowski/dev/service/DoctorService.java[m
[1m+++ b/src/main/java/pl/baranowski/dev/service/DoctorService.java[m
[36m@@ -46,10 +46,15 @@[m [mpublic class DoctorService {[m
 		[m
 	}[m
 [m
[31m-	public DoctorDTO getById(long validatedId) throws EntityNotFoundException {[m
[31m-		Doctor doctor = doctorRepository.findById(validatedId).orElseThrow(EntityNotFoundException::new);[m
[32m+[m	[32mpublic DoctorDTO getDto(long doctorId) throws EntityNotFoundException {[m
[32m+[m		[32mDoctor doctor = get(doctorId);[m
 		return mapper.toDto(doctor);[m
 	}[m
[32m+[m
[32m+[m	[32mprotected Doctor get(long doctorId) {[m
[32m+[m		[32mDoctor doctor = doctorRepository.findById(doctorId).orElseThrow(EntityNotFoundException::new);[m
[32m+[m		[32mreturn doctor;[m
[32m+[m	[32m}[m
 	[m
 	// TODO tests for below method[m
 	public List<Doctor> findByAnimalTypeNameAndMedSpecialtyName(String animalTypeName, String medSpecialtyName) {[m
[1mdiff --git a/src/main/java/pl/baranowski/dev/service/PatientService.java b/src/main/java/pl/baranowski/dev/service/PatientService.java[m
[1mindex 7dea913..04cfef4 100644[m
[1m--- a/src/main/java/pl/baranowski/dev/service/PatientService.java[m
[1m+++ b/src/main/java/pl/baranowski/dev/service/PatientService.java[m
[36m@@ -36,11 +36,16 @@[m [mpublic class PatientService {[m
 		return result.map(entity -> mapper.toDto(entity));[m
 	}[m
 	[m
[31m-	public PatientDTO getById(Long id) {[m
[31m-		Patient result = patientRepo.findById(id).orElseThrow(() -> new EntityNotFoundException("Patient with id " + id + " has not been found."));[m
[32m+[m	[32mpublic PatientDTO getDto(Long patientId) {[m
[32m+[m		[32mPatient result = get(patientId);[m
 		return mapper.toDto(result);[m
 	}[m
 [m
[32m+[m	[32mprotected Patient get(Long patientId) {[m
[32m+[m		[32mPatient result = patientRepo.findById(patientId).orElseThrow(() -> new EntityNotFoundException("Patient with id " + patientId + " has not been found."));[m
[32m+[m		[32mreturn result;[m
[32m+[m	[32m}[m
[32m+[m
 	public PatientDTO addNew(NewPatientDTO newDTO) throws PatientAllreadyExistsException {[m
 		// find provided animalType exists, or throw error[m
 		List<AnimalType> animalTypes = animalTypeRepo.findByName(newDTO.getAnimalTypeName());[m
[1mdiff --git a/src/main/java/pl/baranowski/dev/service/VisitService.java b/src/main/java/pl/baranowski/dev/service/VisitService.java[m
[1mindex aa34099..5bc27cf 100644[m
[1m--- a/src/main/java/pl/baranowski/dev/service/VisitService.java[m
[1m+++ b/src/main/java/pl/baranowski/dev/service/VisitService.java[m
[36m@@ -1,10 +1,5 @@[m
 package pl.baranowski.dev.service;[m
 [m
[31m-import java.time.DayOfWeek;[m
[31m-import java.time.Instant;[m
[31m-import java.time.ZoneId;[m
[31m-import java.time.ZonedDateTime;[m
[31m-import java.util.ArrayList;[m
 import java.util.List;[m
 import java.util.stream.Collectors;[m
 [m
[36m@@ -15,17 +10,20 @@[m [mimport org.springframework.data.domain.Page;[m
 import org.springframework.data.domain.Pageable;[m
 import org.springframework.stereotype.Service;[m
 [m
[31m-import pl.baranowski.dev.dto.SingleCheckResultDTO;[m
[32m+[m[32mimport pl.baranowski.dev.dto.AvailableSlotsAtTheDoctorDTO;[m
 import pl.baranowski.dev.dto.VisitDTO;[m
[31m-import pl.baranowski.dev.entity.Patient;[m
 import pl.baranowski.dev.entity.Doctor;[m
[32m+[m[32mimport pl.baranowski.dev.entity.Patient;[m
 import pl.baranowski.dev.entity.Visit;[m
[31m-import pl.baranowski.dev.exception.NewVisitNotPossibleException;[m
[31m-import pl.baranowski.dev.exception.SearchRequestInvalidException;[m
 import pl.baranowski.dev.exception.DoctorNotActiveException;[m
[32m+[m[32mimport pl.baranowski.dev.exception.InvalidEpochTimeException;[m
[32m+[m[32mimport pl.baranowski.dev.exception.NewVisitNotPossibleException;[m
 import pl.baranowski.dev.mapper.CustomMapper;[m
[31m-import pl.baranowski.dev.repository.PatientRepository;[m
[32m+[m[32mimport pl.baranowski.dev.model.AvailableSlotsAtTheDoctor;[m
[32m+[m[32mimport pl.baranowski.dev.model.AvailableSlotsFinder;[m
[32m+[m[32mimport pl.baranowski.dev.model.EpochFutureTimeRange;[m
 import pl.baranowski.dev.repository.DoctorRepository;[m
[32m+[m[32mimport pl.baranowski.dev.repository.PatientRepository;[m
 import pl.baranowski.dev.repository.VisitRepository;[m
 [m
 @Service[m
[36m@@ -41,6 +39,8 @@[m [mpublic class VisitService {[m
 	CustomMapper mapper;[m
 	@Autowired[m
 	DoctorService doctorService;[m
[32m+[m	[32m@Autowired[m
[32m+[m	[32mPatientService patientService;[m
 [m
 	public VisitDTO getById(long id) {[m
 		Visit result = findByIdOrThrow(id);[m
[36m@@ -58,227 +58,30 @@[m [mpublic class VisitService {[m
 	}[m
 [m
 	public VisitDTO addNew(Long doctorId, Long patientId, Long epochInSeconds) throws NewVisitNotPossibleException, DoctorNotActiveException {[m
[31m-		throwIfEpochIsNotInFuture(epochInSeconds);[m
[31m-[m
[31m-		Doctor doctor = getDoctorOrThrowIfNotFound(doctorId);[m
[31m-		throwIfDoctorBusyAt(epochInSeconds, doctorId);[m
[31m-		throwIfDoctorIsInactive(doctorId, doctor);[m
[31m-		throwIfDoctorDoesNotWorkAtEpoch(epochInSeconds, doctor);[m
[31m-		[m
[31m-		Patient patient = getPatientOrThowIfNotFound(patientId, doctor);[m
[31m-		throwIfPatientBusyAt(epochInSeconds, patientId);[m
[31m-		throwIfAnimalTypeNotMatch(doctor, patient);[m
[31m-		[m
[32m+[m		[32mDoctor doctor = doctorService.get(doctorId);[m
[32m+[m		[32mPatient patient = patientService.get(patientId);[m
 		Visit newVisit = buildNewVisit(epochInSeconds, doctor, patient);[m
 		[m
[31m-		Visit result = visitRepository.saveAndFlush([m
[31m-				newVisit);[m
[32m+[m		[32mVisit result = visitRepository.saveAndFlush(newVisit);[m
 		return mapper.toDto(result);[m
 	}[m
 [m
[31m-	private Visit buildNewVisit(Long epochInSeconds, Doctor doctor, Patient patient) {[m
[32m+[m	[32mprivate Visit buildNewVisit(Long epochInSeconds, Doctor doctor, Patient patient) throws NewVisitNotPossibleException, DoctorNotActiveException {[m
 		return new Visit.VisitBuilder(doctor, patient, epochInSeconds).build();[m
 	}[m
[31m-[m
[31m-	private void throwIfAnimalTypeNotMatch(Doctor doctor, Patient patient) throws NewVisitNotPossibleException {[m
[31m-		if(!doctor.getAnimalTypes().contains(patient.getAnimalType())) {[m
[31m-			throw new NewVisitNotPossibleException("Doctor does not have animalType: " + patient.getAnimalType());[m
[31m-		}[m
[31m-	}[m
[31m-[m
[31m-	private void throwIfDoctorIsInactive(Long doctorId, Doctor doctor) throws DoctorNotActiveException {[m
[31m-		if(!doctor.isActive()) {[m
[31m-			throw new DoctorNotActiveException("Creating Visit failed. Doctor with id " + doctorId + " is not active.");[m
[31m-		}[m
[31m-	}[m
[31m-[m
[31m-	private void throwIfEpochIsNotInFuture(Long epochInSeconds) throws NewVisitNotPossibleException {[m
[31m-		if(epochInSeconds - System.currentTimeMillis()/1000 < 0) {[m
[31m-			throw new NewVisitNotPossibleException("Creating new Visit failed: provided epoch time is not in the future.");[m
[31m-		}[m
[31m-	}[m
[31m-	[m
[31m-	/* Checks, if Doctor has any visits at epoch. If so, throws exception.[m
[31m-	 * Unconfirmed visits are also considered.[m
[31m-	 * TODO checking, if Doctor is not on vacation[m
[31m-	 */[m
[31m-	private void throwIfDoctorBusyAt(long time, long doctorId) throws NewVisitNotPossibleException {[m
[31m-		List<Visit> result = visitRepository.findByEpochAndDoctorId(time, doctorId);[m
[31m-		if(result.size() >= 1) {[m
[31m-			String errorMessage = generateMessageWithArrayOfVisits("Doctor", time, doctorId, result);[m
[31m-			throw new NewVisitNotPossibleException(errorMessage);[m
[31m-		}[m
[31m-	}[m
[31m-	[m
[31m-	private String generateMessageWithArrayOfVisits(String field, long time, long id, List<Visit> result) {[m
[31m-		StringBuilder message = new StringBuilder(field + " with id " + id + "is busy at time " + time + ". ");[m
[31m-		message.append("Enrolled visits: [");[m
[31m-		result.forEach(visit -> message.append(visit.getId().toString() + ", "));[m
[31m-		// replaces last ", " to "]"[m
[31m-		message.replace(message.length()-2, message.length() -1, "]");[m
[31m-		return message.toString();[m
[31m-	}[m
[31m-[m
[31m-	/*[m
[31m-	 * Checks, if Patient has any visits at epoch.[m
[31m-	 * Unconfirmed visits are also considered.[m
[31m-	 */[m
[31m-	private void throwIfPatientBusyAt(long time, long patientId) throws NewVisitNotPossibleException {[m
[31m-		List<Visit> result = visitRepository.findByEpochAndPatientId(time, patientId);[m
[31m-		if(result.size() >= 1) {[m
[31m-			String errorMessage = generateMessageWithArrayOfVisits("Patient", time, patientId, result);[m
[31m-			throw new NewVisitNotPossibleException(errorMessage);[m
[31m-		}[m
[31m-	}[m
[31m-[m
[31m-	private Doctor getDoctorOrThrowIfNotFound(Long doctorId) throws DoctorNotActiveException {[m
[31m-		Doctor doctor = doctorRepository.findById(doctorId).orElseThrow(() -> new EntityNotFoundException("Doctor with id " + doctorId + " has not been found."));[m
[31m-		[m
[31m-		return doctor;[m
[31m-	}[m
[31m-[m
[31m-	private void throwIfDoctorDoesNotWorkAtEpoch(Long epochInSeconds, Doctor doctor) throws NewVisitNotPossibleException {[m
[31m-		if(!doesDoctorWorkAtEpoch(doctor, epochInSeconds)) {[m
[31m-			throwWithMessage();[m
[31m-		}[m
[31m-	}[m
[31m-	[m
[31m-	private void throwWithMessage() throws NewVisitNotPossibleException {[m
[31m-		throw new NewVisitNotPossibleException("Creating new Visit failed: time is: outside working hours, outside of working days, or not at the top of the hour.");[m
[31m-	}[m
[31m-	[m
[31m-	private Boolean doesDoctorWorkAtEpoch(Doctor doctor, long epochInSeconds) {[m
[31m-		int worksFromHour = doctor.getWorksFrom();[m
[31m-		int worksUntilHour = doctor.getWorksTill();[m
[31m-		List<DayOfWeek> doctorWorkingDays = doctor.getWorkingDays();[m
[31m-		[m
[31m-		ZonedDateTime zoned = convertToZonedDateTime(epochInSeconds);[m
[31m-		[m
[31m-		long defaultVisitTimeInSeconds = 60*60; // 1 hour[m
[31m-		[m
[31m-		if(isZonedAtTopHour(zoned)) {[m
[31m-			return false;[m
[31m-		}[m
[31m-[m
[31m-		if(!doesDoctorWorksAtDate(doctorWorkingDays, zoned)) {[m
[31m-			return false;[m
[31m-		}[m
[31m-		if(doesDoctorWorksAtTime(worksFromHour, worksUntilHour, zoned)) {[m
[31m-			return false;[m
[31m-		}[m
[31m-		[m
[31m-		// checks, if visit will end after till (after the end of working day)[m
[31m-		long secondsToWorkingDayEnd = preciseEndOfWorkingDay(worksUntilHour, zoned) - zoned.toEpochSecond();[m
[31m-		if(secondsToWorkingDayEnd > 0 && secondsToWorkingDayEnd < defaultVisitTimeInSeconds) {[m
[31m-			return false;[m
[31m-		}[m
[31m-		return true;[m
[31m-	}[m
[31m-[m
[31m-	private ZonedDateTime convertToZonedDateTime(long epochInSeconds) {[m
[31m-		Instant instant =  Instant.ofEpochSecond(epochInSeconds);[m
[31m-		ZonedDateTime zoned = instant.atZone(ZoneId.systemDefault());[m
[31m-		return zoned;[m
[31m-	}[m
[31m-	[m
[31m-	private boolean isZonedAtTopHour(ZonedDateTime zoned) {[m
[31m-		return zoned.getSecond() != 0 || zoned.getMinute() != 0;[m
[31m-	}[m
[31m-[m
[31m-	private boolean doesDoctorWorksAtDate(List<DayOfWeek> doctorWorkingDays, ZonedDateTime zoned) {[m
[31m-		return doctorWorkingDays.contains(zoned.getDayOfWeek());[m
[31m-	}[m
[31m-[m
[31m-	private boolean doesDoctorWorksAtTime(int worksFromHour, int worksUntilHour, ZonedDateTime zoned) {[m
[31m-		return zoned.getHour()<worksFromHour || zoned.getHour()>=worksUntilHour;[m
[31m-	}[m
[31m-[m
[31m-	private long preciseEndOfWorkingDay(int worksUntilHour, ZonedDateTime zoned) {[m
[31m-		return zoned.withHour(worksUntilHour).withMinute(0).withSecond(0).withNano(0).toEpochSecond();[m
[31m-	}[m
 	[m
[31m-	private Patient getPatientOrThowIfNotFound(Long patientId, Doctor doctor) throws NewVisitNotPossibleException {[m
[31m-		Patient patient = patientRepository.findById(patientId).orElseThrow(() -> new EntityNotFoundException("Patient with id " + patientId + " has not been found."));[m
[32m+[m	[32mpublic List<AvailableSlotsAtTheDoctorDTO> findAvailableSlotsAtTheDoctorsWithParams(String animalTypeName, String medSpecialtyName, String epochStart, String epochEnd) throws InvalidEpochTimeException {[m
[32m+[m		[32mList<Doctor> matchingDoctors = findDoctorsWithSpecialities(animalTypeName, medSpecialtyName);[m
[32m+[m		[32mEpochFutureTimeRange timeRange = EpochFutureTimeRange.fromStrings(epochStart, epochEnd);[m[41m		[m
[32m+[m		[32mAvailableSlotsFinder slotsFinder = new AvailableSlotsFinder(matchingDoctors, timeRange);[m
[32m+[m		[32mList<AvailableSlotsAtTheDoctor> availableSlots = slotsFinder.find();[m
 		[m
[31m-		return patient;[m
[32m+[m		[32mList<AvailableSlotsAtTheDoctorDTO> availableSlotsDTO = availableSlots.stream().map(mapper::toDto).collect(Collectors.toList());[m
[32m+[m		[32mreturn availableSlotsDTO;[m
 	}[m
[31m-	[m
[31m-[m
 [m
[31m-	[m
[31m-	// TODO tests...[m
[31m-	public List<SingleCheckResultDTO> findFreeSlots(String animalTypeName, String medSpecialtyName, String epochStart, String epochEnd, String intervalStr) throws SearchRequestInvalidException {[m
[31m-		// decodes validated epoch start[m
[31m-		long start = Long.decode(epochStart);[m
[31m-		// decodes validated epoch end[m
[31m-		long end = Long.decode(epochEnd);[m
[31m-		// decodes validated interval[m
[31m-		long interval = Long.decode(intervalStr);[m
[31m-		[m
[31m-		// finds Doctors with matching AnimalType and MedSpecialty[m
[31m-		List<Doctor> matchingDoctors = doctorService.findByAnimalTypeNameAndMedSpecialtyName(animalTypeName, medSpecialtyName);[m
[31m-[m
[31m-		// creates list of SingleCheckResultDTO and populates it with Doctors and their free times[m
[31m-		List<SingleCheckResultDTO> result = new ArrayList<>();[m
[31m-		for(Doctor doctor: matchingDoctors) {[m
[31m-			result.add(new SingleCheckResultDTO(mapper.toDto(doctor), findFreeSlotsForDoctor(doctor, start, end, interval)));[m
[31m-		}[m
[31m-			[m
[31m-		return result;[m
[31m-	}[m
[31m-	[m
[31m-	public List<Long> findFreeSlotsForDoctor(Doctor doctor, Long epochStart, Long epochEnd, Long interval) throws SearchRequestInvalidException {[m
[31m-		// validate epochs' values[m
[31m-		if(epochStart >= epochEnd) {[m
[31m-			throw new SearchRequestInvalidException("Searching request not valid: epoch start should be less than epoch end.");[m
[31m-		}[m
[31m-		if(epochStart < System.currentTimeMillis()/1000) {[m
[31m-			throw new SearchRequestInvalidException("Searching request not valid: epoch start should be later than now.");[m
[31m-		}[m
[31m-		[m
[31m-		// generates times list (e.g. 9:00, 10:00, 11:00) between epochStart (9:00) and End (11:00) with interval (1 hour = 3600s)[m
[31m-		List<Long> topHours = createTimeSlots(epochStart, epochEnd, interval);[m
[31m-		[m
[31m-		// reduces times list by taken (busy) slots[m
[31m-		List<Long> result = topHours.stream()[m
[31m-				.filter(hour -> !doctor.isBusyAt(hour, interval))[m
[31m-				.collect(Collectors.toList());[m
[31m-		[m
[31m-		return result;[m
[32m+[m	[32mprivate List<Doctor> findDoctorsWithSpecialities(String animalTypeName, String medSpecialtyName) {[m
[32m+[m		[32mreturn doctorService.findByAnimalTypeNameAndMedSpecialtyName(animalTypeName, medSpecialtyName);[m
 	}[m
 	[m
[31m-	[m
[31m-	/**[m
[31m-	 * Generates times list from epochStart (inclusive) to epochEnd (inclusive) with interval.[m
[31m-	 * Example:[m
[31m-	 * epochStart = 1894006800 (GMT: Monday, 7 January 2030 09:00:00),[m
[31m-	 * epochEnd = 1894014000 (GMT: Monday, 7 January 2030 09:00:00),[m
[31m-	 * interval = 900 (15 min),[m
[31m-	 * Result: 1894006800, 1894007700, 1894008600, 1894009500, 1894010400, 1894011300, 1894012200, 1894013100, 1894014000[m
[31m-	 * @param epochStart inclusive, seconds[m
[31m-	 * @param epochEnd inclusive, seconds[m
[31m-	 * @param interval seconds[m
[31m-	 * @return epoch time list, seconds[m
[31m-	 */[m
[31m-	public List<Long> createTimeSlots(long epochStart, long epochEnd, long interval) {[m
[31m-		List<Long> result = new ArrayList<>();[m
[31m-		/*[m
[31m-		 *  epochStart % one hour (3600s) = minutes from last top hour (remainder)[m
[31m-		 *  epochStart - remainder + one hour = first top hour after epochStart[m
[31m-		 */[m
[31m-		long remainder = (epochStart % interval);[m
[31m-		long top = epochStart;[m
[31m-		top += remainder > 0 ? -remainder + interval : 0; // if remainder 0, subtract reminder and add 1 hour[m
[31m-		for(; top<=epochEnd; top+=interval) { // epochEnd inclusive[m
[31m-			result.add(top);[m
[31m-		}[m
[31m-		System.out.println(result);[m
[31m-		return result;[m
[31m-	}[m
[31m-[m
[31m-[m
[31m-	[m
[31m-[m
[31m-	[m
[31m-	[m
 }[m
[1mdiff --git a/src/test/java/pl/baranowski/dev/controller/DoctorControllerTest.java b/src/test/java/pl/baranowski/dev/controller/DoctorControllerTest.java[m
[1mindex 88fb0e3..fd86d0e 100644[m
[1m--- a/src/test/java/pl/baranowski/dev/controller/DoctorControllerTest.java[m
[1m+++ b/src/test/java/pl/baranowski/dev/controller/DoctorControllerTest.java[m
[36m@@ -99,7 +99,7 @@[m [mpublic class DoctorControllerTest {[m
 	@Test[m
 	void getById_whenValidId_returns200AndEntry() throws Exception {[m
 		DoctorDTO expected = this.mostowiak;[m
[31m-		given(doctorService.getById(expected.getId())).willReturn(expected);[m
[32m+[m		[32mgiven(doctorService.getDto(expected.getId())).willReturn(expected);[m
 		[m
 		MvcResult result = mockMvc.perform(get("/doctor/{id}", expected.getId()))[m
 				.andExpect(status().isOk()).andReturn();[m
[36m@@ -122,7 +122,7 @@[m [mpublic class DoctorControllerTest {[m
 	@Test[m
 	void getById_whenValidIdAndNoEntry_returns404AndError() throws Exception {[m
 		ErrorDTO expected = new ErrorDTO(new EntityNotFoundException(), HttpStatus.NOT_FOUND);[m
[31m-		given(doctorService.getById(1L)).willThrow(EntityNotFoundException.class);[m
[32m+[m		[32mgiven(doctorService.getDto(1L)).willThrow(EntityNotFoundException.class);[m
 		[m
 		MvcResult result = mockMvc.perform(get("/doctor/{id}", 1L))[m
 				.andExpect(status().isNotFound()).andReturn();[m
[1mdiff --git a/src/test/java/pl/baranowski/dev/controller/PatientControllerTest.java b/src/test/java/pl/baranowski/dev/controller/PatientControllerTest.java[m
[1mindex 42cd049..b8a0cfe 100644[m
[1m--- a/src/test/java/pl/baranowski/dev/controller/PatientControllerTest.java[m
[1m+++ b/src/test/java/pl/baranowski/dev/controller/PatientControllerTest.java[m
[36m@@ -69,13 +69,13 @@[m [mclass PatientControllerTest {[m
 [m
 	@Test[m
 	void getById_whenEntityExists_callsCorrectlyAndReturnsDTO() throws Exception {[m
[31m-		given(patientService.getById(patientDTO.getId())).willReturn(patientDTO);[m
[32m+[m		[32mgiven(patientService.getDto(patientDTO.getId())).willReturn(patientDTO);[m
 		MvcResult result = mockMvc.perform(get("/patient/{id}", patientDTO.getId()))[m
 				.andExpect(status().isOk())[m
 				.andReturn();[m
 		[m
 		ArgumentCaptor<Long> idCaptor = ArgumentCaptor.forClass(Long.class);[m
[31m-		verify(patientService, times(1)).getById(idCaptor.capture());[m
[32m+[m		[32mverify(patientService, times(1)).getDto(idCaptor.capture());[m
 		[m
 		// verifies business call[m
 		assertEquals(patientDTO.getId(), idCaptor.getValue());[m
[36m@@ -85,7 +85,7 @@[m [mclass PatientControllerTest {[m
 	@Test[m
 	void getById_whenEntityDoNotExists_throwsEntityNotFoundException() throws Exception {[m
 		EntityNotFoundException expectedException = new EntityNotFoundException("test");[m
[31m-		given(patientService.getById(patientDTO.getId())).willThrow(expectedException);[m
[32m+[m		[32mgiven(patientService.getDto(patientDTO.getId())).willThrow(expectedException);[m
 		MvcResult result = mockMvc.perform(get("/patient/{id}", patientDTO.getId()))[m
 				.andExpect(status().isNotFound())[m
 				.andReturn();[m
[36m@@ -99,7 +99,7 @@[m [mclass PatientControllerTest {[m
 	void getById_whenInvalidId_throwsNumberFormatException() throws Exception {[m
 		String invalidId = "a";[m
 		NumberFormatException expectedException = generateNumberFormatExceptionForString(invalidId);[m
[31m-		given(patientService.getById(patientDTO.getId())).willThrow(expectedException);[m
[32m+[m		[32mgiven(patientService.getDto(patientDTO.getId())).willThrow(expectedException);[m
 		MvcResult result = mockMvc.perform(get("/patient/{id}", invalidId))[m
 				.andExpect(status().isBadRequest())[m
 				.andReturn();[m
[1mdiff --git a/src/test/java/pl/baranowski/dev/service/PatientServiceTest.java b/src/test/java/pl/baranowski/dev/service/PatientServiceTest.java[m
[1mindex 223cea9..c1039d3 100644[m
[1m--- a/src/test/java/pl/baranowski/dev/service/PatientServiceTest.java[m
[1m+++ b/src/test/java/pl/baranowski/dev/service/PatientServiceTest.java[m
[36m@@ -61,11 +61,11 @@[m [mclass PatientServiceTest {[m
 	void getById() {[m
 		//whenEntityExists - returnsDTO[m
 		given(patientRepository.findById(patient.getId())).willReturn(Optional.of(patient));[m
[31m-		assertEquals(mapper.toDto(patient), patientService.getById(patient.getId()));[m
[32m+[m		[32massertEquals(mapper.toDto(patient), patientService.getDto(patient.getId()));[m
 		[m
 		//whenEntityDoesNotExists - throwsEntityNotFoundException[m
 		given(patientRepository.findById(patient.getId())).willReturn(Optional.empty());[m
[31m-		assertThrows(EntityNotFoundException.class, () -> patientService.getById(patient.getId()));[m
[32m+[m		[32massertThrows(EntityNotFoundException.class, () -> patientService.getDto(patient.getId()));[m
 	}[m
 	[m
 	@Test[m
[1mdiff --git a/src/test/java/pl/baranowski/dev/service/VetServiceTest.java b/src/test/java/pl/baranowski/dev/service/VetServiceTest.java[m
[1mindex ceee73c..233ef7b 100644[m
[1m--- a/src/test/java/pl/baranowski/dev/service/VetServiceTest.java[m
[1m+++ b/src/test/java/pl/baranowski/dev/service/VetServiceTest.java[m
[36m@@ -79,7 +79,7 @@[m [mclass DoctorServiceTest {[m
 		Long id = 1L;[m
 		Optional<Doctor> expected = Optional.of(mostowiak);[m
 		given(doctorRepository.findById(id)).willReturn(expected);[m
[31m-		DoctorDTO result = doctorService.getById(id);[m
[32m+[m		[32mDoctorDTO result = doctorService.getDto(id);[m
 		assertEquals(mapper.toDto(expected.get()), result);[m
 	}[m
 [m
[36m@@ -89,7 +89,7 @@[m [mclass DoctorServiceTest {[m
 		[m
 		given(doctorRepository.findById(id)).willReturn(Optional.empty());[m
 [m
[31m-		assertThrows(EntityNotFoundException.class, () -> doctorService.getById(id));[m
[32m+[m		[32massertThrows(EntityNotFoundException.class, () -> doctorService.getDto(id));[m
 	}[m
 	[m
 	@Test[m
[1mdiff --git a/src/test/java/pl/baranowski/dev/service/VisitServiceTest.java b/src/test/java/pl/baranowski/dev/service/VisitServiceTest.java[m
[1mindex 7908ec2..54eb540 100644[m
[1m--- a/src/test/java/pl/baranowski/dev/service/VisitServiceTest.java[m
[1m+++ b/src/test/java/pl/baranowski/dev/service/VisitServiceTest.java[m
[36m@@ -60,7 +60,6 @@[m [mclass VisitServiceTest {[m
 	@MockBean[m
 	PatientRepository patientRepository;[m
 [m
[31m-	// Below we present to You our todays Heroes:[m
 	long mondayH10Y2100 = ZonedDateTime.of(LocalDateTime.of(2100, 1, 25, 10, 00, 00), ZoneId.systemDefault()).toEpochSecond();[m
 	AnimalType animalType = new AnimalType(1L, "Owad");[m
 	MedSpecialty medSpecialty = new MedSpecialty(2L, "CzÃ³Å‚kolog");[m
[36m@@ -291,11 +290,4 @@[m [mclass VisitServiceTest {[m
 		assertThrows(SearchRequestInvalidException.class, () -> visitService.findFreeSlotsForDoctor(doctor, startBeforeNow, endEqual, 3600L));[m
 	}[m
 	[m
[31m-	@Test[m
[31m-	void genTopHoursBetween() {[m
[31m-		long start = mondayH10Y2100 + 30*60; // 2100-01-25 10:30:00;[m
[31m-		long end = mondayH10Y2100 + 24*60*60 - 30*60; // 2100-01-26 9:30:00;[m
[31m-		assertEquals(23, visitService.createTimeSlots(start, end, 3600L).size());[m
[31m-	}[m
[31m-	[m
 }[m
